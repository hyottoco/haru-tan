<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ãƒãƒ«ç†Ÿ 400</title>

  <style>
    :root{
      --bd:#ddd; --bd-dark:#2a2f3a;
      --bg:#fff; --fg:#111;
      --muted:#666;
      --card:#fff; --card-dark:#171a21;

      --pill-pad-y:6px; --pill-pad-x:8px; --pill-radius:999px;
      --btn-radius:12px;

      /* å¾©ç¿’ç³» */
      --review-bg:#f3f6fb; --review-bd:#cfd8e3; --review-fg:#334155;
      --review-bg-hover:#e9eef7; --review-accent:#64748b;

      /* wheel */
      --wheel-item-h:44px;
      --wheel-fade:rgba(255,255,255,0.9);
      --wheel-fade-dark:rgba(15,17,21,0.85);
    }

    body{
      font-family:system-ui,-apple-system,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;
      margin:0; padding:5px;
      background:var(--bg); color:var(--fg);
      transition:background .2s ease,color .2s ease;
    }

    .card{
      max-width:820px;
      margin:0 auto;
      padding:18px;
      border:1px solid var(--bd);
      border-radius:14px;
      background:var(--card);
      position:relative;
      transition:background .2s ease,border-color .2s ease;
    }

    /* PC/iPadï¼šç¸¦é•·è¦‹ãˆ */
    @media (min-width:768px){
      .card{ max-width:300px; }
    }

    .page-title{
      font-size:16px;
      font-weight:700;
      margin:0 0 12px;
      text-align:center;
      letter-spacing:.03em;
      user-select:none;
    }

    /* è¡Œãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
    .row{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .topbar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .topbar-right{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }

    /* å…±é€šUIï¼ˆbadge/pill/smallï¼‰ */
    .badge,.pill,button.small{
      font-size:16px;
      line-height:1;
      padding:var(--pill-pad-y) var(--pill-pad-x);
      border-radius:var(--pill-radius);
      border:1px solid var(--bd);
      background:transparent;
      color:inherit;
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
      white-space:nowrap;
      transition:background .2s ease,border-color .2s ease,color .2s ease;
    }
    .pill{ cursor:pointer; }
    button.small{ cursor:pointer; }
    button.small:active{ transform:translateY(1px); }

    button{
      font-size:16px;
      padding:10px 14px;
      border-radius:var(--btn-radius);
      border:1px solid var(--bd);
      background:#fff;
      color:#111;
      cursor:pointer;
      transition:background .2s ease,border-color .2s ease,color .2s ease;
    }
    button:active{ transform:translateY(1px); }

    .primary{ font-weight:500; }
    .danger{ border-color:#f2c; }
    .toggle{ border-color:#88c; }
    .pill.togglePill{ border-color:#88c; }

    /* iPhoneãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—æ‹¡å¤§ãªã©æŠ‘åˆ¶ */
    button, label, .pill{
      -webkit-tap-highlight-color:transparent;
      touch-action:manipulation;
    }

    /* å¾©ç¿’UI */
    .reviewUI{
      background:var(--review-bg);
      border-color:var(--review-bd);
      color:var(--review-fg);
      border-radius:14px;
    }
    @media (hover:hover) and (pointer:fine){
      .reviewUI:hover{ background:var(--review-bg-hover); }
    }
    @media (hover:none){
      .reviewUI:hover{ background:var(--review-bg); }
    }
    .pressWhite:active{
      background:#fff;
      border-color:var(--review-bd);
      color:var(--review-fg);
    }

    .pill input[type="checkbox"]{
      width:18px; height:18px; margin:0;
      accent-color:#88c;
      transform:translateY(.5px);
    }
    .reviewUI input[type="checkbox"]{ accent-color:var(--review-accent); }
    .pill .count{ opacity:.85; font-variant-numeric:tabular-nums; }

    /* 1è¡Œç›®/2è¡Œç›®é«˜ã•èª¿æ•´ */
    .topbar .badge,
    .topbar-right button.small{
      padding-top:12px; padding-bottom:12px;
    }

    /* å¾©ç¿’è¡Œ */
    .reviewRow{
      display:flex; align-items:center; gap:10px;
      flex-wrap:nowrap;
    }
    .reviewRow-right{
      margin-left:auto;
      display:flex; align-items:center; gap:10px;
    }
    .reviewRow .pill,
    .reviewRow button.small{
      padding-top:12px; padding-bottom:12px;
    }
    @media (max-width:360px){
      .reviewRow{ flex-wrap:wrap; }
      .reviewRow-right{
        width:100%;
        justify-content:flex-end;
        margin-left:0;
      }
    }

    /* ç¯„å›² + Auto + ç¾åœ¨No */
    .rangeWrap{
      width:100%;
      display:grid;
      grid-template-columns:1fr auto;
      row-gap:6px;
      column-gap:10px;
    }
    .rangeTop{ grid-column:1 / 3; display:contents; }
    .rangeBadge{
      grid-column:1;
      width:fit-content;
      justify-self:start;
    }
    #autoBtn{ grid-column:2; white-space:nowrap; }
    .rangeNow{
      grid-column:2;
      display:flex;
      align-items:center;
      gap:8px;
      padding-left:2px;
    }
    @media (max-width:360px){
      .rangeWrap{ grid-template-columns:1fr; }
      #autoBtn, .rangeNow{ grid-column:1; }
    }

    .rangeInput{
      width:3.5em;
      padding:6px;
      border:1px solid var(--bd);
      border-radius:10px;
      font-size:14px;
      background:transparent;
      color:inherit;
      text-align:left;
    }
    .rangeInput::-webkit-outer-spin-button,
    .rangeInput::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0; }
    .rangeInput[type="number"]{ appearance:textfield; }

    .word-no,.word-num-header{
      font-size:14px;
      font-weight:600;
      color:var(--muted);
      line-height:1;
      user-select:none;
    }

    .displayArea{ min-height:155px; }
    .word{ margin:18px 0 10px; line-height:1.1; word-break:break-word; }
    .word-text{ font-size:30px; font-weight:400; }
    .meaning{
      font-size:20px;
      margin:10px 0 0;
      min-height:40px;
      word-break:break-word;
      overflow-wrap:anywhere;
    }

    .btns{
      display:flex;
      gap:10px;
      margin-top:16px;
      flex-wrap:wrap;
      align-items:center;
    }
    #nextBtn{ width:100%; }

    /* å¾©ç¿’ãƒªã‚¹ãƒˆã«è¿½åŠ  */
    .missBox{
      display:none;
      margin-top:12px;
      padding:6px;
      border:1px solid var(--bd);
      border-radius:12px;
      align-items:center;
      gap:10px;
      background:rgba(0,0,0,0.02);

      width:100%;
      box-sizing:border-box;
      justify-content:center;
      cursor:pointer;
    }
    .missBox.show{ display:flex; }
    .missBox input{ width:22px; height:22px; margin:0; cursor:pointer; }
    .missBox .label{ font-size:14px; user-select:none; white-space:nowrap; }

    /* æ¢ã™è¡Œ */
    .searchRow{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:nowrap;
    }
    .searchRow-right{
      margin-left:auto;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:nowrap;
      min-width:0;
    }
    .searchRow > button,
    .searchRow-right > button{ font-size:14px; }

    /* ç™ºéŸ³é€Ÿåº¦ */
    .speedBox{
      display:flex;
      align-items:center;
      gap:4px;
      padding:8px;
      border:1px solid var(--bd);
      border-radius:999px;
      background:transparent;
      user-select:none;
      width:fit-content;
    }
    .speedBox input[type="range"]{ width:48px; margin:0; }
    .speedBox .val{
      font-size:13px;
      font-variant-numeric:tabular-nums;
      white-space:nowrap;
      opacity:.9;
      min-width:2.0em;
      text-align:right;
    }

    /* Autoæ™‚é–“ */
    .autoTimeRow{
      margin-top:8px;
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:nowrap;
    }
    .autoTimeBadge{
      flex:0 0 auto;
      width:fit-content;
      display:flex;
      align-items:center;
      gap:6px;
      flex-wrap:nowrap;
      overflow:hidden;
    }
    .msInput{
      width:2.5em;
      padding:4px 8px;
      border:1px solid var(--bd);
      border-radius:10px;
      font-size:14px;
      background:transparent;
      color:inherit;
    }
    .msInput::-webkit-outer-spin-button,
    .msInput::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0; }
    .msInput[type="number"]{ appearance:textfield; }
    .miniLbl{ font-size:13px; opacity:.85; }
    .unit{ font-size:12px; opacity:.75; }
    button.small.miniBtn{
      font-size:14px;
      padding:6px 8px;
      border-radius:999px;
      line-height:1;
      white-space:nowrap;
    }

    /* WakeLock badge */
    .wakeBadge{
      position:fixed;
      top:calc(env(safe-area-inset-top) + 8px);
      right:8px;
      font-size:11px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--bd);
      background:rgba(255,255,255,0.75);
      user-select:none;
      display:none;
      z-index:99999;
      align-items:center;
      gap:8px;
    }
    .wakeBadge.show{ display:inline-flex; }
    .wakeDot{ width:7px; height:7px; border-radius:999px; background:#999; }
    .wakeDot.on{ background:#22c55e; }
    .wakeDot.off{ background:#ef4444; }

    /* ãƒ€ãƒ¼ã‚¯ */
    body.dark{ background:#0f1115; color:#e9e9ea; }
    body.dark .card{ background:var(--card-dark); border-color:var(--bd-dark); }
    body.dark .badge,
    body.dark button.small,
    body.dark .pill{
      border-color:var(--bd-dark);
      background:rgba(255,255,255,0.03);
      color:#d6d6d8;
    }
    body.dark button{
      background:#1f2430;
      border-color:var(--bd-dark);
      color:#e9e9ea;
    }
    body.dark .rangeInput,
    body.dark .msInput,
    body.dark .speedBox{ border-color:var(--bd-dark); }
    body.dark .word-num-header{ color:#aaa; }
    body.dark .reviewUI{
      background:rgba(255,255,255,0.06);
      border-color:var(--bd-dark);
      color:#e5e7eb;
    }
    body.dark .pressWhite:active{
      background:rgba(255,255,255,0.16);
      border-color:var(--bd-dark);
      color:#e5e7eb;
    }
    body.dark .missBox{
      border-color:var(--bd-dark);
      background:rgba(255,255,255,0.03);
    }
    body.dark .wakeBadge{
      border-color:var(--bd-dark);
      background:rgba(0,0,0,0.25);
    }

    /* ===== wheel modal ===== */
    .modalOverlay{
      position:fixed; inset:0;
      background:rgba(0,0,0,0.35);
      display:none;
      align-items:flex-end;
      justify-content:center;
      padding:calc(env(safe-area-inset-top) + 10px) 14px calc(env(safe-area-inset-bottom) + 14px);
      z-index:9999;
    }
    .modalOverlay.show{ display:flex; }

    .modalSheet{
      width:min(500px,100%);
      border-radius:18px;
      border:1px solid var(--bd);
      background:#fff;
      color:#111;
      box-shadow:0 12px 40px rgba(0,0,0,.18);
      overflow:hidden;
      transform:translateY(8px);
      animation:sheetIn .16s ease-out forwards;
      max-height:calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - 20px);
      overflow:auto;
      -webkit-overflow-scrolling:touch;
    }
    @keyframes sheetIn{ to{ transform:translateY(0); } }
    body.dark .modalSheet{
      background:#171a21;
      color:#e9e9ea;
      border-color:var(--bd-dark);
      box-shadow:0 12px 40px rgba(0,0,0,.35);
    }

    .modalHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:6px 12px;
      border-bottom:1px solid var(--bd);
      gap:10px;
    }
    body.dark .modalHeader{ border-bottom-color:var(--bd-dark); }
    .modalTitle{
      font-size:14px;
      font-weight:700;
      letter-spacing:.02em;
      opacity:.95;
      user-select:none;
    }
    .mini{
      font-size:14px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid var(--bd);
      background:transparent;
      color:inherit;
      cursor:pointer;
    }
    body.dark .mini{
      border-color:var(--bd-dark);
      background:rgba(255,255,255,0.03);
    }

    .wheelSearchRow{
      display:flex;
      gap:8px;
      padding:6px;
      border-bottom:1px solid var(--bd);
    }
    body.dark .wheelSearchRow{ border-bottom-color:var(--bd-dark); }

    .wheelSearch{
      flex:1;
      border:1px solid var(--bd);
      border-radius:12px;
      padding:10px 12px;
      font-size:14px;
      background:transparent;
      color:inherit;
      outline:none;
    }
    body.dark .wheelSearch{ border-color:var(--bd-dark); }

    .wheelArea{ position:relative; padding:12px 12px 2px; }
    .wheelViewport{
      position:relative;
      height:calc(var(--wheel-item-h) * 7);
      overflow-y:auto;
      -webkit-overflow-scrolling:touch;
      scroll-snap-type:y mandatory;
      overscroll-behavior:contain;
      border-radius:16px;
      border:1px solid var(--bd);
      background:rgba(0,0,0,0.02);
      touch-action:pan-y;
    }
    body.dark .wheelViewport{
      border-color:var(--bd-dark);
      background:rgba(255,255,255,0.03);
    }
    .wheelFadeTop,.wheelFadeBottom{
      pointer-events:none;
      position:absolute;
      left:12px; right:12px;
      height:44px;
      z-index:2;
    }
    .wheelFadeTop{ top:12px; background:linear-gradient(to bottom,var(--wheel-fade),rgba(255,255,255,0)); }
    .wheelFadeBottom{ bottom:2px; background:linear-gradient(to top,var(--wheel-fade),rgba(255,255,255,0)); }
    body.dark .wheelFadeTop{ background:linear-gradient(to bottom,var(--wheel-fade-dark),rgba(15,17,21,0)); }
    body.dark .wheelFadeBottom{ background:linear-gradient(to top,var(--wheel-fade-dark),rgba(15,17,21,0)); }

    .wheelList{ padding:calc(var(--wheel-item-h)*3) 0; margin:0; list-style:none; }
    .wheelItem{
      height:var(--wheel-item-h);
      display:flex;
      align-items:center;
      justify-content:center;
      scroll-snap-align:center;
      user-select:none;
      padding:0 14px;
    }
    .wheelItemInner{
      width:100%;
      max-width:92%;
      text-align:left;
      padding:8px 10px;
      border-radius:14px;
      border:1px solid transparent;
      line-height:1.15;
      word-break:break-word;
      overflow-wrap:anywhere;
      display:grid;
      grid-template-columns:3.2em 1fr;
      column-gap:10px;
      align-items:center;
    }
    .wheelItemInner .num{
      font-size:12px;
      opacity:.70;
      font-variant-numeric:tabular-nums;
      user-select:none;
    }
    .wheelItemInner .main{ font-size:18px; font-weight:500; }
    .wheelItemInner .ja{
      display:block;
      font-size:12px;
      opacity:.70;
      margin-top:2px;
      line-height:1.2;
    }
    .wheelItem.isActive .wheelItemInner{
      border-color:rgba(100,116,139,0.25);
      background:rgba(100,116,139,0.06);
    }

    .wheelHint{
      font-size:12px;
      opacity:.75;
      padding:0 12px 10px;
      user-select:none;
      min-height:1.2em;
    }
    .wheelFooter{
      display:flex;
      gap:10px;
      padding:8px;
      border-top:1px solid var(--bd);
      justify-content:flex-end;
      flex-wrap:wrap;
      align-items:center;
    }
    body.dark .wheelFooter{ border-top-color:var(--bd-dark); }
  </style>
</head>

<body>
  <div class="card">
    <h1 id="pageTitle" class="page-title"></h1>

    <div class="topbar">
      <div class="badge" id="progress">0 / 0</div>
      <div class="topbar-right">
        <button id="resetBtn" class="small reviewUI" type="button">Reset</button>
        <button class="small reviewUI pressWhite" id="clearWrongBtn" type="button">å¾©ç¿’Reset</button>
      </div>
    </div>

    <div class="row reviewRow">
      <label class="pill togglePill reviewUI" for="wrongOnlyToggle">
        <input type="checkbox" id="wrongOnlyToggle" />
        å¾©ç¿’ <span class="count" id="wrongCount">(0)</span>
      </label>

      <div class="reviewRow-right">
        <button class="small toggle" id="audioToggle" type="button">ğŸ”Š</button>
        <button class="small toggle" id="themeToggle" type="button">ğŸŒ™</button>
        <button class="small toggle" id="orderToggle" type="button">ğŸ”€</button>
      </div>
    </div>

    <div class="row">
      <div class="rangeWrap">
        <div class="rangeTop">
          <label class="badge rangeBadge">
            No
            <input id="rangeFrom" class="rangeInput" type="number" min="1">
            ã€œ
            <input id="rangeTo" class="rangeInput" type="number" min="1">
          </label>

          <button class="small toggle" id="autoBtn" type="button">â–¶ï¸ Auto</button>
        </div>

        <div class="rangeNow">
          <span class="word-no">No</span>
          <span id="wordNumHeader" class="word-num-header"></span>
        </div>
      </div>
    </div>

    <div class="displayArea">
      <div class="word">
        <span class="word-text" id="wordText">ï¼ˆreadingâ€¦ï¼‰</span>
      </div>
      <div class="meaning" id="meaning"></div>
    </div>

    <div class="btns">
      <button class="primary" id="nextBtn" type="button">ã¯ã˜ã‚ã‚‹</button>
    </div>

    <label class="missBox reviewUI" id="missBox">
      <input type="checkbox" id="missToggle">
      <span class="label">å¾©ç¿’ãƒªã‚¹ãƒˆã«è¿½åŠ </span>
    </label>

    <div class="btns searchRow">
      <button id="wheelOpenBtn" type="button">ğŸ¡ æ¢ã™</button>

      <div class="searchRow-right">
        <div class="speedBox" title="ç™ºéŸ³é€Ÿåº¦ã‚’èª¿æ•´ã—ã¾ã™">
          <input id="rateRange" type="range" min="0.6" max="1.2" step="0.1" value="1.0" />
          <span id="rateLabel" class="val">1.0x</span>
        </div>

        <button id="speakBtn" type="button">ğŸ”Š ç™ºéŸ³</button>
      </div>
    </div>

    <div class="row autoTimeRow">
      <div class="badge autoTimeBadge">
        â–¶ï¸
        <span class="miniLbl">è‹±</span>
        <input id="autoEnMs" class="msInput" type="number" min="200" max="9999" step="100">
        <span class="unit">ms</span>
        <span class="unit">:</span>
        <span class="miniLbl">æ—¥</span>
        <input id="autoJaMs" class="msInput" type="number" min="200" max="9999" step="100">
        <span class="unit">ms</span>
      </div>
      <button class="small miniBtn reviewUI pressWhite" id="autoTimeResetBtn" type="button">åˆæœŸå€¤</button>
    </div>

    <div class="wakeBadge" id="wakeBadge" title="Autoä¸­ã¯ã‚¹ãƒªãƒ¼ãƒ—ã—ã«ããã—ã¾ã™ï¼ˆå¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ã®ã¿ï¼‰">
      <span class="wakeDot off" id="wakeDot"></span>
      <span id="wakeText">Wake: OFF</span>
    </div>
  </div>

  <!-- ğŸ¡ ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div class="modalOverlay" id="wheelOverlay" aria-hidden="true">
    <div class="modalSheet" role="dialog" aria-modal="true" aria-labelledby="wheelTitle">
      <div class="modalHeader">
        <div class="modalTitle" id="wheelTitle">ğŸ¡ å˜èªæ¤œç´¢ï¼ˆè‹±oræ—¥ï¼‰</div>
        <button class="mini" id="wheelCloseBtn" type="button">é–‰ã˜ã‚‹</button>
      </div>

      <div class="wheelSearchRow">
        <input class="wheelSearch" id="wheelSearchInput" type="search" placeholder="ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œç´¢" autocomplete="off" />
        <button class="mini" id="wheelClearSearchBtn" type="button">ã‚¯ãƒªã‚¢</button>
      </div>

      <div class="wheelArea">
        <div class="wheelFadeTop"></div>
        <div class="wheelFadeBottom"></div>

        <div class="wheelViewport" id="wheelViewport">
          <ul class="wheelList" id="wheelList"></ul>
        </div>
      </div>

      <div class="wheelHint" id="wheelHint"></div>

      <div class="wheelFooter">
        <button class="mini" id="wheelJumpBtn" type="button">ã“ã®å˜èªã¸ç§»å‹•</button>
      </div>
    </div>
  </div>

<script>
/* =========================
   VOCABï¼ˆã‚ãªãŸã®ãƒ‡ãƒ¼ã‚¿ã«ç½®æ›ï¼‰
========================= */
const VOCAB = [
  { en: "want to ~", ja: "ï½ã—ãŸã„" },
  { en: "a lot of ~", ja: "ãŸãã•ã‚“ã®ï½" },
  { en: "have to ~", ja: "ï½ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„" },
  { en: "It is ~ to ...", ja: "â€¦ã™ã‚‹ã®ã¯ï½ã " },
  { en: "come to ~", ja: "ï½ã«æ¥ã‚‹" },
  // ...ï¼ˆçœç•¥ï¼šã‚ãªãŸã®VOCABã‚’ãã®ã¾ã¾ç½®ã„ã¦OKï¼‰
  { en: "a number of ~", ja: "å¤šæ•°ã®ï½" }
];

/* =========================
   Utils
========================= */
const $ = (id) => document.getElementById(id);

const LS = {
  get(key, fallback){
    try{
      const v = localStorage.getItem(key);
      return v == null ? fallback : JSON.parse(v);
    }catch{ return fallback; }
  },
  set(key, value){
    try{ localStorage.setItem(key, JSON.stringify(value)); }catch{}
  }
};

const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

/* =========================
   Voice utilityï¼ˆè‹±èªéŸ³å£°é¸æŠï¼‰
========================= */
function pickEnglishVoice(){
  const voices = speechSynthesis.getVoices() || [];
  return (
    voices.find(v => v.lang === "en-US" && /Alex/i.test(v.name)) ||
    voices.find(v => v.lang === "en-US") ||
    voices.find(v => v.lang.startsWith("en-"))
  ) || null;
}

let cachedEnglishVoice = null;

if ("speechSynthesis" in window) {
  speechSynthesis.onvoiceschanged = () => {
    cachedEnglishVoice = pickEnglishVoice();
  };
}

const toInt = (v, fallback) => {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
};
const escapeHtml = (s) => String(s ?? "")
  .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
  .replaceAll('"',"&quot;").replaceAll("'","&#39;");

/* =========================
   Elements
========================= */
const pageTitle = $("pageTitle");
const progressEl = $("progress");
const wordTextEl = $("wordText");
const meaningEl = $("meaning");
const wordNumHeader = $("wordNumHeader");

const nextBtn = $("nextBtn");
const resetBtn = $("resetBtn");
const clearWrongBtn = $("clearWrongBtn");

const wrongOnlyToggle = $("wrongOnlyToggle");
const wrongCount = $("wrongCount");

const missBox = $("missBox");
const missToggle = $("missToggle");

const autoBtn = $("autoBtn");
const audioToggle = $("audioToggle");
const themeToggle = $("themeToggle");
const orderToggle = $("orderToggle");

const rangeFrom = $("rangeFrom");
const rangeTo = $("rangeTo");

const wheelOpenBtn = $("wheelOpenBtn");
const speakBtn = $("speakBtn");

const rateRange = $("rateRange");
const rateLabel = $("rateLabel");

const autoEnMsInput = $("autoEnMs");
const autoJaMsInput = $("autoJaMs");
const autoTimeResetBtn = $("autoTimeResetBtn");

const wakeBadge = $("wakeBadge");
const wakeDot = $("wakeDot");
const wakeText = $("wakeText");

/* wheel */
const wheelOverlay = $("wheelOverlay");
const wheelCloseBtn = $("wheelCloseBtn");
const wheelSearchInput = $("wheelSearchInput");
const wheelClearSearchBtn = $("wheelClearSearchBtn");
const wheelList = $("wheelList");
const wheelViewport = $("wheelViewport");
const wheelJumpBtn = $("wheelJumpBtn");
const wheelHint = $("wheelHint");

/* =========================
   State
   - APPã”ã¨ã®localStorageè¡çªã‚’é¿ã‘ã‚‹ãŸã‚ title ã‚’ã‚­ãƒ¼åŒ–
========================= */
const APP_ID  = (document.title || "vocab").replace(/\s+/g, "_");
const APP_KEY = `ei_idiom_state_v3__${APP_ID}`;

const state = {
  idx: 0,
  orderRandom: false,
  audioOn: true,
  dark: false,

  wrongSet: {},      // { realIndex: true }
  wrongOnly: false,

  rangeFrom: 1,
  rangeTo: VOCAB.length,

  shuffled: [],      // å®Ÿindexé…åˆ—ï¼ˆç¯„å›²ï¼†å¾©ç¿’ã§ä½œã‚‹ï¼‰
  started: false,
  phase: 0,          // 0:è‹±/å‡ºé¡Œ, 1:æ—¥/ç­”ãˆ

  rate: 1.0,

  autoOn: false,
  autoEnMs: 1500,
  autoJaMs: 1000,

  vocabLen: VOCAB.length
};

function loadState(){
  const saved = LS.get(APP_KEY, null);
  if(!saved) return;

  const b = (k, t) => (typeof saved[k] === t);
  if(b("idx","number")) state.idx = saved.idx;
  if(b("orderRandom","boolean")) state.orderRandom = saved.orderRandom;
  if(b("audioOn","boolean")) state.audioOn = saved.audioOn;
  if(b("dark","boolean")) state.dark = saved.dark;
  if(saved.wrongSet && typeof saved.wrongSet === "object") state.wrongSet = saved.wrongSet;
  if(b("wrongOnly","boolean")) state.wrongOnly = saved.wrongOnly;

  if(b("rangeFrom","number")) state.rangeFrom = saved.rangeFrom;
  if(b("rangeTo","number")) state.rangeTo = saved.rangeTo;

  if(Array.isArray(saved.shuffled)) state.shuffled = saved.shuffled;

  if(b("started","boolean")) state.started = saved.started;
  if(b("phase","number")) state.phase = saved.phase;

  if(b("rate","number")) state.rate = saved.rate;

  if(b("autoOn","boolean")) state.autoOn = saved.autoOn;
  if(b("autoEnMs","number")) state.autoEnMs = saved.autoEnMs;
  if(b("autoJaMs","number")) state.autoJaMs = saved.autoJaMs;

  /* èªæ•°ãŒé•ã†ã‚¢ãƒ—ãƒª/æ›´æ–°ãªã‚‰å®‰å…¨ã«åˆæœŸåŒ– */
  if(typeof saved.vocabLen === "number" && saved.vocabLen !== VOCAB.length){
    state.idx = 0;
    state.started = false;
    state.phase = 0;
    state.wrongSet = {};
    state.wrongOnly = false;
    state.rangeFrom = 1;
    state.rangeTo = VOCAB.length;
    state.shuffled = [];
  }

  state.vocabLen = VOCAB.length;
}

function saveState(){
  LS.set(APP_KEY, state);
}

/* =========================
   Order / Range
========================= */
function inRangeIndices(){
  const a = clamp(toInt(state.rangeFrom, 1), 1, VOCAB.length);
  const b = clamp(toInt(state.rangeTo, VOCAB.length), 1, VOCAB.length);
  const lo = Math.min(a, b);
  const hi = Math.max(a, b);
  const arr = [];
  for(let i = lo - 1; i <= hi - 1; i++) arr.push(i);
  return arr;
}

function shuffle(arr){
  const a = arr.slice();
  for(let i = a.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function buildOrder(){
  const base = inRangeIndices();
  const pool = state.wrongOnly ? base.filter(i => state.wrongSet[i]) : base;

  if(pool.length === 0){
    state.shuffled = [];
    state.idx = 0;
    return;
  }
  state.shuffled = state.orderRandom ? shuffle(pool) : pool;
  state.idx = 0;
}

function currentRealIndex(){
  if(state.shuffled.length === 0) return null;
  return state.shuffled[clamp(state.idx, 0, state.shuffled.length - 1)];
}

function syncRangeConstraints(){
  rangeFrom.max = String(state.rangeTo);
  rangeTo.min   = String(state.rangeFrom);

  rangeFrom.value = String(state.rangeFrom);
  rangeTo.value   = String(state.rangeTo);
}

/* =========================
   Speech
========================= */
function speak(text){
  if(!state.audioOn) return;
  if(!("speechSynthesis" in window)) return;

  try{ speechSynthesis.cancel(); }catch(e){}

  // â˜… iPadå¯¾ç­–ï¼šã¾ã å–ã‚Œã¦ãªã‘ã‚Œã°æ¯å›æ‹¾ã„ç›´ã™
  if(!cachedEnglishVoice){
    cachedEnglishVoice = pickEnglishVoice();
  }

  const u = new SpeechSynthesisUtterance(text);
  u.lang = "en-US";
  u.rate = clamp(Number(state.rate) || 1.0, 0.6, 1.4);

  if (cachedEnglishVoice) u.voice = cachedEnglishVoice;

  speechSynthesis.speak(u);
}



function speakCurrent(){
  const real = currentRealIndex();
  if(real == null) return;
  speak(VOCAB[real].en);
}

/* =========================
   Wake Lock
========================= */
let wakeLockSentinel = null;
let wakeKeepAliveTimer = 0;

function setWakeUI(on, reason){
  wakeBadge.classList.toggle("show", !!state.autoOn);
  wakeDot.classList.toggle("on", !!on);
  wakeDot.classList.toggle("off", !on);
  wakeText.textContent = on ? "Wake: ON" : "Wake: OFF";
  if(reason && state.autoOn) wakeBadge.title = reason;
}

async function requestWakeLock(){
  setWakeUI(false, "WakeLockã‚’å–å¾—ä¸­â€¦");
  try{
    if("wakeLock" in navigator && navigator.wakeLock?.request){
      wakeLockSentinel = await navigator.wakeLock.request("screen");
      setWakeUI(true, "WakeLock: Screen Wake Lock APIã§ç¶­æŒä¸­");

      wakeLockSentinel.addEventListener("release", () => {
        wakeLockSentinel = null;
        if(state.autoOn && document.visibilityState === "visible"){
          requestWakeLock().catch(()=>{});
        }else{
          setWakeUI(false, "WakeLock: OFF");
        }
      });
      return;
    }
  }catch{}

  /* iPhone Safariç­‰ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆæ“¬ä¼¼ keep-aliveï¼‰ */
  clearInterval(wakeKeepAliveTimer);
  wakeKeepAliveTimer = setInterval(() => { void Date.now(); }, 25_000);
  setWakeUI(false, "ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯WakeLockéå¯¾å¿œã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼ˆiPhone Safariç­‰ï¼‰ã€‚Autoä¸­ã¯æ™‚ã€…ç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ç¶­æŒã—ã‚„ã™ã„ã§ã™ã€‚");
}

async function releaseWakeLock(){
  try{ if(wakeLockSentinel) await wakeLockSentinel.release(); }catch{}
  wakeLockSentinel = null;

  if(wakeKeepAliveTimer){
    clearInterval(wakeKeepAliveTimer);
    wakeKeepAliveTimer = 0;
  }
  setWakeUI(false, "WakeLock: OFF");
}

document.addEventListener("visibilitychange", () => {
  if(!state.autoOn) return;
  if(document.visibilityState === "visible"){
    requestWakeLock().catch(()=>{});
  }
});

/* =========================
   Render / UI
========================= */
function updateAutoBtn(){
  autoBtn.textContent = state.autoOn ? "â¸ Auto" : "â–¶ï¸ Auto";
}

function updateTopUI(){
  const total = state.shuffled.length;
  const cur = (!state.started || !total) ? 0 : (state.idx + 1);
  progressEl.textContent = `${cur} / ${total}`;

  const real = currentRealIndex();
  wordNumHeader.textContent = (!state.started || real == null) ? "" : String(real + 1);

  wrongOnlyToggle.checked = !!state.wrongOnly;
  orderToggle.textContent = state.orderRandom ? "ğŸ”€" : "ğŸ”¢";
  audioToggle.textContent = state.audioOn ? "ğŸ”Š" : "ğŸ”‡";
  themeToggle.textContent = state.dark ? "ğŸŒ™" : "â˜€ï¸";

  /* å¾©ç¿’ã‚«ã‚¦ãƒ³ãƒˆï¼šç¯„å›²å†…ã®å¾©ç¿’æ•° */
  const base = inRangeIndices();
  const cnt = base.filter(i => state.wrongSet[i]).length;
  wrongCount.textContent = `(${cnt})`;

  rateRange.value = String(state.rate);
  rateLabel.textContent = `${state.rate.toFixed(1)}x`;

  autoEnMsInput.value = String(state.autoEnMs);
  autoJaMsInput.value = String(state.autoJaMs);

  syncRangeConstraints();
  updateAutoBtn();
}

function render(){
  pageTitle.textContent = document.title;

  const real = currentRealIndex();
  updateTopUI();

  if(real != null){
    missToggle.checked = !!state.wrongSet[real];
  }

  if(real == null){
    wordTextEl.textContent = "ãƒªã‚¹ãƒˆãŒç©ºã§ã™";
    meaningEl.textContent = "ç¯„å›²ã‚’åºƒã’ã‚‹ã‹ã€ã€Œå¾©ç¿’ã€ã‚’OFFã«ã™ã‚‹ã‹ã€å¾©ç¿’ãƒªã‚¹ãƒˆã‚’ç™»éŒ²ã—ã¦ã­";
    nextBtn.textContent = "ã¯ã˜ã‚ã‚‹";
    state.started = false;
    state.phase = 0;
    missBox.classList.remove("show");
    missToggle.checked = false;
    saveState();
    return;
  }

  if(!state.started){
    wordTextEl.textContent = "Ready Steady GO!";
    meaningEl.textContent = "";
    nextBtn.textContent = "ã¯ã˜ã‚ã‚‹";
    missBox.classList.remove("show");
    missToggle.checked = false;
    saveState();
    return;
  }

  const item = VOCAB[real];
  wordTextEl.textContent = item.en;

if(state.phase === 0){
  meaningEl.textContent = "";
  nextBtn.textContent = "æ—¥æœ¬èªè¨³ã‚’ç¢ºèªï¼ˆç­”ãˆåˆã‚ã›ï¼‰";
}else{
  meaningEl.textContent = item.ja;
  nextBtn.textContent = "æ­£è§£ã ã£ãŸã‹ãªï¼Ÿ æ¬¡ã®å˜èªã¸ï¼";
}

/* â˜… å¸¸æ™‚è¡¨ç¤º */
missBox.classList.add("show");

/* â˜… ãƒã‚§ãƒƒã‚¯çŠ¶æ…‹ã¯å¸¸ã«ç¾åœ¨ã®å˜èªã«åŒæœŸ */
missToggle.checked = !!state.wrongSet[real];


  saveState();
}

/* =========================
   Manual controls
========================= */
let autoTimer = 0;

function stopAuto(){
  state.autoOn = false;
  if(autoTimer) clearTimeout(autoTimer);
  autoTimer = 0;
  updateAutoBtn();
  saveState();
  releaseWakeLock().catch(()=>{});
}

function startOrAdvance(){
  stopAuto();

  const real = currentRealIndex();
  if(real == null){ render(); return; }

  if(!state.started){
    state.started = true;
    state.phase = 0;
    render();
    speakCurrent();
    return;
  }

  if(state.phase === 0){
    state.phase = 1;
    render();
    return;
  }

  state.idx = (state.idx >= state.shuffled.length - 1) ? 0 : state.idx + 1;
  state.phase = 0;
  render();
  speakCurrent();
}

function hardReset(){
  stopAuto();
  state.idx = 0;
  state.started = false;
  state.phase = 0;
  buildOrder();
  render();
}

function clearWrong(){
  stopAuto();
  state.wrongSet = {};
  state.idx = 0;
  state.started = false;
  state.phase = 0;
  buildOrder();
  render();
}

function applyRangeFromInputs(){
  stopAuto();

  let from = clamp(toInt(rangeFrom.value, 1), 1, VOCAB.length);
  let to   = clamp(toInt(rangeTo.value, VOCAB.length), 1, VOCAB.length);

  /* ãƒ«ãƒ¼ãƒ«ï¼šfrom > to ã‚’è¨±ã•ãªã„ */
  if(from > to) from = to;

  state.rangeFrom = from;
  state.rangeTo   = to;

  buildOrder();
  state.started = false;
  state.phase = 0;
  render();
}

/* =========================
   Auto
========================= */
function scheduleAuto(ms){
  if(autoTimer) clearTimeout(autoTimer);
  autoTimer = setTimeout(autoTick, ms);
}

function startAuto(){
  const real = currentRealIndex();
  if(real == null) return;

  state.autoOn = true;
  updateAutoBtn();
  saveState();

  requestWakeLock().catch(()=>{});
  setWakeUI(!!wakeLockSentinel, wakeBadge.title);

  autoTick();
}

function autoTick(){
  if(!state.autoOn) return;

  const real = currentRealIndex();
  if(real == null){
    stopAuto();
    render();
    return;
  }

  if(!state.started){
    state.started = true;
    state.phase = 0;
    render();
    speakCurrent();
    scheduleAuto(state.autoEnMs);
    return;
  }

  if(state.phase === 0){
    state.phase = 1;
    render();
    scheduleAuto(state.autoJaMs);
    return;
  }

  state.idx = (state.idx >= state.shuffled.length - 1) ? 0 : state.idx + 1;
  state.phase = 0;
  render();
  speakCurrent();
  scheduleAuto(state.autoEnMs);
}

/* Autoæ™‚é–“UI */
function sanitizeMs(v, min, max, fallback){
  const n = Number(v);
  if(!Number.isFinite(n)) return fallback;
  return clamp(Math.round(n), min, max);
}

/* =========================
   Wheel (Search)
   - ç¯„å›²å†…(ï¼‹å¾©ç¿’ONãªã‚‰å¾©ç¿’å†…)ã ã‘å€™è£œã«ã™ã‚‹
========================= */
let wheelFiltered = [];
let wheelActiveIndex = 0;
let wheelSnapTimer = 0;

function wheelCandidateIndices(){
  const base = inRangeIndices();
  return state.wrongOnly ? base.filter(i => state.wrongSet[i]) : base;
}
function wheelMatch(q, item){
  if(!q) return true;
  const s = q.toLowerCase();
  return (item.en || "").toLowerCase().includes(s) || (item.ja || "").toLowerCase().includes(s);
}

function updateWheelHint(){
  const total = wheelFiltered.length;
  wheelHint.textContent = (total === 0) ? "è©²å½“ãªã—" : `${total}ä»¶`;
}

function wheelUpdateActiveClass(){
  const items = wheelList.querySelectorAll(".wheelItem");
  items.forEach((li, idx) => li.classList.toggle("isActive", idx === wheelActiveIndex));
}

function wheelScrollToIndex(i, smooth){
  const items = wheelList.querySelectorAll(".wheelItem");
  if(!items.length) return;

  const idx = clamp(i, 0, items.length - 1);
  const target = items[idx];

  const top = target.offsetTop + (target.offsetHeight / 2) - (wheelViewport.clientHeight / 2);
  wheelViewport.scrollTo({ top, behavior: smooth ? "smooth" : "auto" });

  wheelActiveIndex = idx;
  wheelUpdateActiveClass();
}

function wheelPickNearest(){
  const items = wheelList.querySelectorAll(".wheelItem");
  if(!items.length) return 0;

  const centerY = wheelViewport.scrollTop + wheelViewport.clientHeight / 2;
  let best = 0, bestDist = Infinity;

  items.forEach((el, i) => {
    const y = el.offsetTop + el.offsetHeight / 2;
    const d = Math.abs(y - centerY);
    if(d < bestDist){ bestDist = d; best = i; }
  });
  return best;
}

function wheelSnap(){
  wheelScrollToIndex(wheelPickNearest(), true);
}

function renderWheelItems(){
  wheelList.innerHTML = "";
  wheelFiltered.forEach((v, idx) => {
    const li = document.createElement("li");
    li.className = "wheelItem";
    li.dataset.index = String(idx);
    li.innerHTML = `
      <div class="wheelItemInner">
        <div class="num">${v.i + 1}</div>
        <div>
          <div class="main">${escapeHtml(v.en)}</div>
          <span class="ja">${escapeHtml(v.ja)}</span>
        </div>
      </div>
    `;
    wheelList.appendChild(li);
  });

  wheelActiveIndex = clamp(wheelActiveIndex, 0, Math.max(0, wheelFiltered.length - 1));
  wheelUpdateActiveClass();
}

function rebuildWheelList(){
  const q = (wheelSearchInput.value || "").trim();
  const candidates = wheelCandidateIndices();

  wheelFiltered = candidates
    .map(i => ({ ...VOCAB[i], i }))
    .filter(v => wheelMatch(q, v));

  wheelActiveIndex = 0;
  renderWheelItems();
  updateWheelHint();
  wheelViewport.scrollTop = 0;

  requestAnimationFrame(() => wheelScrollToIndex(0, false));
}

function openWheel(){
  stopAuto();
  wheelOverlay.classList.add("show");
  wheelOverlay.setAttribute("aria-hidden", "false");
  wheelSearchInput.value = "";
  wheelActiveIndex = 0;
  rebuildWheelList();
  setTimeout(()=>wheelSearchInput.focus(), 50);
}
function closeWheel(){
  wheelOverlay.classList.remove("show");
  wheelOverlay.setAttribute("aria-hidden", "true");
}
function wheelJumpToSelected(){
  stopAuto();
  if(wheelFiltered.length === 0) return;

  const picked = wheelFiltered[wheelActiveIndex];
  if(!picked) return;

  const pos = state.shuffled.indexOf(picked.i);
  if(pos < 0){
    wheelHint.textContent = "ã“ã®å˜èªã¯ç¾åœ¨ã®ç¯„å›²ã«ã‚ã‚Šã¾ã›ã‚“ï¼ˆç¯„å›²ã‚’åºƒã’ã¦ãã ã•ã„ï¼‰";
    return;
  }

  state.idx = pos;
  state.started = true;
  state.phase = 0;
  render();
  closeWheel();
}

/* =========================
   Events
========================= */
nextBtn.addEventListener("click", startOrAdvance);
resetBtn.addEventListener("click", hardReset);
clearWrongBtn.addEventListener("click", clearWrong);

autoBtn.addEventListener("click", () => {
  if(state.autoOn) stopAuto();
  else startAuto();
});

wrongOnlyToggle.addEventListener("change", () => {
  stopAuto();
  state.wrongOnly = wrongOnlyToggle.checked;
  buildOrder();
  state.started = false;
  state.phase = 0;
  render();
});

missToggle.addEventListener("change", () => {
  const real = currentRealIndex();
  if(real == null) return;

  if(missToggle.checked) state.wrongSet[real] = true;
  else delete state.wrongSet[real];

  render(); // countæ›´æ–°ã‚‚å«ã‚ã‚‹
});

audioToggle.addEventListener("click", () => {
  stopAuto();
  state.audioOn = !state.audioOn;
  if(!state.audioOn){
    try{ window.speechSynthesis.cancel(); }catch{}
  }
  render();
});

themeToggle.addEventListener("click", () => {
  stopAuto();
  state.dark = !state.dark;
  document.body.classList.toggle("dark", state.dark);
  render();
});

orderToggle.addEventListener("click", () => {
  stopAuto();
  state.orderRandom = !state.orderRandom;
  buildOrder();
  state.started = false;
  state.phase = 0;
  render();
});

/* range */
rangeFrom.addEventListener("change", applyRangeFromInputs);
rangeTo.addEventListener("change", applyRangeFromInputs);

/* rate */
rateRange.addEventListener("input", () => {
  state.rate = Number(rateRange.value);
  rateLabel.textContent = `${state.rate.toFixed(1)}x`;
  saveState();
});

/* speak */
speakBtn.addEventListener("click", () => {
  stopAuto();
  const real = currentRealIndex();
  if(real == null) return;
  speak(VOCAB[real].en);
});

/* auto time */
autoEnMsInput.addEventListener("change", () => {
  stopAuto();
  state.autoEnMs = sanitizeMs(autoEnMsInput.value, 200, 10000, 1500);
  autoEnMsInput.value = String(state.autoEnMs);
  saveState();
});
autoJaMsInput.addEventListener("change", () => {
  stopAuto();
  state.autoJaMs = sanitizeMs(autoJaMsInput.value, 200, 20000, 1000);
  autoJaMsInput.value = String(state.autoJaMs);
  saveState();
});
autoTimeResetBtn.addEventListener("click", () => {
  stopAuto();
  state.autoEnMs = 1500;
  state.autoJaMs = 1000;
  autoEnMsInput.value = String(state.autoEnMs);
  autoJaMsInput.value = String(state.autoJaMs);
  saveState();
});

/* wheel */
wheelOpenBtn.addEventListener("click", openWheel);
wheelCloseBtn.addEventListener("click", closeWheel);
wheelClearSearchBtn.addEventListener("click", () => { wheelSearchInput.value = ""; rebuildWheelList(); });
wheelSearchInput.addEventListener("input", rebuildWheelList);
wheelJumpBtn.addEventListener("click", wheelJumpToSelected);

wheelList.addEventListener("click", (e) => {
  const li = e.target.closest(".wheelItem");
  if(!li) return;
  const idx = parseInt(li.dataset.index || "0", 10);
  if(!Number.isFinite(idx)) return;
  wheelScrollToIndex(idx, true);
});

wheelViewport.addEventListener("scroll", () => {
  clearTimeout(wheelSnapTimer);
  wheelSnapTimer = setTimeout(() => {
    if (wheelOverlay.classList.contains("show")) wheelSnap();
  }, 140);
}, { passive:true });

wheelOverlay.addEventListener("click", (e) => { if(e.target === wheelOverlay) closeWheel(); });
document.addEventListener("keydown", (e) => { if(e.key === "Escape" && wheelOverlay.classList.contains("show")) closeWheel(); });

/* =========================
   Init
========================= */
(function init(){
  rangeFrom.min = "1";
  rangeTo.min = "1";
  rangeFrom.max = String(VOCAB.length);
  rangeTo.max = String(VOCAB.length);

  loadState();

  /* clamp */
  state.rangeFrom = clamp(toInt(state.rangeFrom, 1), 1, VOCAB.length);
  state.rangeTo   = clamp(toInt(state.rangeTo, VOCAB.length), 1, VOCAB.length);
  if(state.rangeFrom > state.rangeTo) state.rangeFrom = state.rangeTo;

  state.rate = clamp(Number(state.rate) || 1.0, 0.6, 1.4);
  state.autoEnMs = clamp(Number(state.autoEnMs) || 1500, 200, 10000);
  state.autoJaMs = clamp(Number(state.autoJaMs) || 1000, 200, 20000);

  document.body.classList.toggle("dark", state.dark);

  /* order */
  if(!Array.isArray(state.shuffled) || state.shuffled.length === 0){
    buildOrder();
  }else{
    const base = new Set(inRangeIndices());
    const ok = state.shuffled.every(i => base.has(i));
    if(!ok) buildOrder();
    state.idx = clamp(state.idx, 0, Math.max(0, state.shuffled.length - 1));
  }

  /* safety: reloadã§Autoå‹æ‰‹ã«é–‹å§‹ã—ãªã„ */
  state.autoOn = false;
  if(autoTimer) clearTimeout(autoTimer);
  autoTimer = 0;
  setWakeUI(false, "WakeLock: OFF");

  syncRangeConstraints();
  render();

  // â˜… iOS/iPadOSå¯¾ç­–ï¼švoicesã‚’å–å¾—ã—ã«è¡Œãï¼ˆç©ºé…åˆ—å¯¾ç­–ï¼‰
  if ("speechSynthesis" in window) {
    cachedEnglishVoice = pickEnglishVoice();
    try { speechSynthesis.getVoices(); } catch(e) {}
  }
})();
</script>
</body>
</html>
